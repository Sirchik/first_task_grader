class LibraryManager
  require "date"
  require 'active_support/all'
 # require 'pry-debugger' 
  #подключаем зависимость к себе (дебагер)
  #require 'active_support/all'
  # 1. Бибилиотека в один момент решила ввести жесткую систему штрафов (прямо как на rubybursa :D). За каждый час опоздания со здачей книги читатель вынужден заплатить пеню 0,1% от стоимости.  Необходимо реализовать метод, который будет считать эту сумму в зависимости от даты выдачи и текущего времени. По работе с датой-временем информацию можно посмотреть тут http://ruby-doc.org/stdlib-2.2.2/libdoc/date/rdoc/DateTime.html
  # Входящие параметры метода 
  # - стоимость книги в центах, 
  # - дата-время когда книга должна была быть сдана. 
  # Возвращаемое значение 
  # - пеня в центах
  def penalty price, issue_datetime
    # решение пишем тут

    current_time = DateTime.now.new_offset
    percentage = price / 100 * 0.1   # пеня 0,1% от стоимости книги
    penalty_time = current_time - issue_datetime
    if penalty_time<=0
      penalt = 0
    else
      penalt = (percentage*(penalty_time*24)).round
    end

  end

  #-----------------------------------------------------------------------
  #return_time = DateTime.now.new_offset-5.hours
  #reader.penalty(1400, return_time)
  #-----------------------------------------------------------------------

  # 2. Известны годы жизни двух писателей. Год рождения, год смерти. Посчитать, могли ли они чисто теоретически встретиться. Даже если один из писателей был в роддоме - это все равно считается встречей. Помните, что некоторые писатели родились и умерли до нашей эры - в таком случае годы жизни будут просто приходить со знаком минус.
  # Входящие параметры метода 
  # - год рождения первого писателя, 
  # - год смерти первого писателя, 
  # - год рождения второго писателя, 
  # - год смерти второго писателя.
  # Возвращаемое значение 
  # - true или false
  def could_meet_each_other? year_of_birth_first, year_of_death_first, year_of_birth_second, year_of_death_second
    # решение пишем тут
    first_life_time = year_of_birth_first..year_of_death_first
    second_life_time = year_of_birth_second..year_of_death_second
    first_life_time.overlaps?(second_life_time) || second_life_time.overlaps?(first_life_time)
  end 
#*********************************************************************************************
=begin
# Мой первый вариант, самому смешно))
     if year_of_birth_first <= year_of_birth_second&&year_of_death_first>=year_of_birth_second||year_of_birth_second<=year_of_birth_first&&year_of_death_second<=year_of_death_first
    return true
     end
    
=end 
#*********************************************************************************************
  # 3. Исходя из жесткой системы штрафов за опоздания со cдачей книг, читатели начали задумываться - а не дешевле ли будет просто купить такую же книгу...  Необходимо помочь читателям это выяснить. За каждый час опоздания со здачей книги читатель вынужден заплатить пеню 0,1% от стоимости.
  # Входящий параметр метода 
  # - стоимость книги в центах 
  # Возвращаемое значение 
  # - число полных дней, нак которые необходимо опоздать со здачей, чтобы пеня была равна стоимости книги.
  def days_to_buy price
    # решение пишем тут
    percentage = price.to_f / 100.0 * 0.1
    amount_days = ((price.to_f / percentage)/24).round
  end
  #*******************************************************************************
  #reader.days_to_bye(250)
  #*******************************************************************************

  # 4. Для удобства иностранных пользователей, имена авторов книг на украинском языке нужно переводить в транслит. Транслитерацию должна выполняться согласно официальным правилам http://kyivpassport.com/transliteratio/
  # Входящий параметр метода 
  # - имя и фамилия автора на украинском. ("Іван Франко") 
  # Возвращаемое значение 
  # - имя и фамилия автора транслитом. ("Ivan Franko")
  def author_translit ukr_name
    # решение пишем тут
    change_hash = {

          
          "а"=>"a",   "б"=>"b",   "в"=>"v",
          "г"=>"h",   "д"=>"d",   "е"=>"e",  "є"=>"ie",
          "ж"=>"zh",  "з"=>"z",   "і"=>"i",
          "и"=>"y",   "й"=>"i",   "к"=>"k",  "ї"=>"i",
          "л"=>"l",   "м"=>"m",   "н"=>"n",  "ґ"=>"g",
          "о"=>"o",   "п"=>"p",   "р"=>"r",
          "с"=>"s",   "т"=>"t",   "у"=>"u",
          "ф"=>"f",   "х"=>"kh",  "ц"=>"ts",
          "ч"=>"ch",  "ш"=>"sh",  "щ"=>"shch",
          "ю"=>"iu",  "я"=>"ia",

          "А"=>"A",   "Б"=>"B",   "В"=>"V",
          "Г"=>"H",   "Д"=>"D",   "Е"=>"E",  "Є"=>"Ye",
          "Ж"=>"Zh",  "З"=>"Z",   "І"=>"I",
          "И"=>"Y",   "Й"=>"Y",   "К"=>"K",  "Ї"=>"Yi",
          "Л"=>"L",   "М"=>"M",   "Н"=>"N",  "Ґ"=>"G",
          "О"=>"O",   "П"=>"P",   "Р"=>"R",
          "С"=>"S",   "Т"=>"T",   "У"=>"U",
          "Ф"=>"F",   "Х"=>"Kh",  "Ц"=>"Ts",
          "Ч"=>"Ch",  "Ш"=>"Sh",  "Щ"=>"Shch",
          "Ю"=>"Yu",  "Я"=>"Ya",  
      }
      change_hash.each do |kay, value|
       
       ukr_name.gsub!(kay, value)  
      end
    return ukr_name.to_s

  end 
  
#************************************************************************************ 
#   ask_name = LibraryManager.new
#   puts "Hi, do you want to know how to convert any word in Ukrainian transliteration?"
#   puts "Please write it on Ukrainian: " 
#   ask_name.convert(gets)
#************************************************************************************

  #5. Читатели любят дочитывать книги во что-бы то ни стало. Необходимо помочь им просчитать сумму штрафа, который придеться заплатить чтобы дочитать книгу, исходя из количества страниц, текущей страницы и скорости чтения за час.
  # Входящий параметр метода 
  # - Стоимость книги в центах
  # - Дата-время сдачи книги (может быть как в прошлом, так и в будущем)
  # - Количество страниц в книге
  # - Текущая страница
  # - Скорость чтения - целое количество страниц в час.
  # Возвращаемое значение 
  # - Пеня в центах или 0 при условии что читатель укладывается в срок здачи.
  def penalty_to_finish price, issue_datetime, pages_quantity, current_page, reading_speed
    # решение пишем тут
    current_time = DateTime.now.new_offset(0)
    percentage = price / 100.0 * 0.1   # пеня 0,1% от стоимости книги
    rest_page = pages_quantity - current_page #кол-во оставшихся страниц
    hours_rest = ((issue_datetime - current_time) * 24.0).round # запас времени
    reading_hours = rest_page / reading_speed #Кол-во чтение-часов
   
    if hours_rest >= reading_hours
      return(0)
         else
          penalty = ((reading_hours - hours_rest) * percentage).round

    end

  end

end
#reader = LibraryManager.new
=begin
#************************************************************

time = DateTime.new(2017,03,02)
print reader.penalty_to_finish(1400, time, 348, 25, 5)

#************************************************************
# => reader.penalty(250, "2015-06-15 22:23:59", 500, 150, 3)
#reader.could_meet_each_other?(10,20,15,22)
LibraryManager.new.penalty(1000,  DateTime.new(2017,03,02)) 
=end 